{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2023-02-14T06:38:48.618Z","updated":"2023-02-14T06:38:48.618Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-02-14T06:38:51.211Z","updated":"2023-02-14T06:38:51.211Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"关于","date":"2023-02-14T06:38:42.968Z","updated":"2023-02-14T06:38:42.968Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"404 Not Found：该页无法显示","date":"2023-02-14T06:38:24.033Z","updated":"2023-02-14T06:38:24.033Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-02-14T06:38:53.914Z","updated":"2023-02-14T06:38:53.914Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"书单","date":"2023-02-14T06:38:45.815Z","updated":"2023-02-14T06:38:45.815Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-02-14T07:32:35.025Z","updated":"2023-02-14T07:32:35.025Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"WSL 中编译 Rocket-chip project","slug":"编译 Rocket-chip project","date":"2023-02-21T13:34:11.935Z","updated":"2023-02-21T13:38:22.067Z","comments":true,"path":"2023/02/21/编译 Rocket-chip project/","link":"","permalink":"http://example.com/2023/02/21/%E7%BC%96%E8%AF%91%20Rocket-chip%20project/","excerpt":"","text":"记录编译过程中遇到的问题和解决方案1. 进入 vsim 目录之后，make verilog 报错 Command &#39;mill&#39; not found 进入 mill 的说明文档网站Installation :: Mill (com-lihaoyi.github.io)，按照提示安装 mill","categories":[{"name":"神明难再的硬件之旅","slug":"神明难再的硬件之旅","permalink":"http://example.com/categories/%E7%A5%9E%E6%98%8E%E9%9A%BE%E5%86%8D%E7%9A%84%E7%A1%AC%E4%BB%B6%E4%B9%8B%E6%97%85/"}],"tags":[{"name":"wsl","slug":"wsl","permalink":"http://example.com/tags/wsl/"},{"name":"riscv","slug":"riscv","permalink":"http://example.com/tags/riscv/"},{"name":"rocket-chip","slug":"rocket-chip","permalink":"http://example.com/tags/rocket-chip/"}]},{"title":"在 WSL 中安装 riscv-toolchain","slug":"编译安装 riscv-toolchain","date":"2023-02-21T08:23:06.630Z","updated":"2023-02-21T12:23:08.144Z","comments":true,"path":"2023/02/21/编译安装 riscv-toolchain/","link":"","permalink":"http://example.com/2023/02/21/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%20riscv-toolchain/","excerpt":"","text":"记录编译安装过程中遇到的问题和解决方案1. 报错 multiple definitions of bitbang_swd 根据报错信息，找到对应的文件，注释掉对应的行 2. 报错 runtime_error is not a member of std 根据报错信息，找到对应的文件，添加 #include &lt;stdexcept&gt; 3. 报错 Multiple definitions of tohost and fromhost 这个错误是编译 riscv-tests 时出现的错误，需要进入到 riscv-tests/isa 目录下，在 Makefile 文件中的编译选项后面添加 -fcommon 编译安装完成之后，但是我并不知道这个对于 rocket-chip 有什么用，和之前安装的嵌入式的 riscv-toolchain 有区别，bin 目录下只有几个二进制文件 4. 以为编译完成之后，尝试运行 spike 的 demo，结果报错 spike pk hello returns “bad syscall” 按照这个Codegen error with upstream gcc · Issue #170 · riscv-software-src/riscv-pk (github.com) 上说的，可以解决，将对应的 memset 函数替换，重新编译即可 运行这个 spike demo 的同时，google 了一下 spike，这是个 riscv 的仿真器，但是不太明白这个和 qemu 有什么区别 5. spike pk 之后，虽然可以运行，但是还是报警告 Warning (interrupt_provider): /cpus/cpu@0/interrupt-controller: Missing #address-cells in interrupt provider 按照这个 Fix warning in new dtc · riscv-software-src/riscv-isa-sim@319da2a (github.com) 进行修改","categories":[{"name":"神明难再的硬件之旅","slug":"神明难再的硬件之旅","permalink":"http://example.com/categories/%E7%A5%9E%E6%98%8E%E9%9A%BE%E5%86%8D%E7%9A%84%E7%A1%AC%E4%BB%B6%E4%B9%8B%E6%97%85/"}],"tags":[{"name":"wsl","slug":"wsl","permalink":"http://example.com/tags/wsl/"},{"name":"riscv","slug":"riscv","permalink":"http://example.com/tags/riscv/"},{"name":"riscv-toolchain","slug":"riscv-toolchain","permalink":"http://example.com/tags/riscv-toolchain/"}]},{"title":"RISC-V CPU译码阶段","slug":"RISC-V CPU译码阶段","date":"2023-02-17T10:56:58.180Z","updated":"2023-02-17T15:26:08.338Z","comments":true,"path":"2023/02/17/RISC-V CPU译码阶段/","link":"","permalink":"http://example.com/2023/02/17/RISC-V%20CPU%E8%AF%91%E7%A0%81%E9%98%B6%E6%AE%B5/","excerpt":"","text":"RISC-V 有四种寻址方式（立即数寻址、寄存器寻址、基址寻址、pc 相对寻址），这些寻址方式决定了一条指令主要是与通用寄存器和立即数打交道，因此首先需要实现通用寄存器模块。 Regfile 模块1. 设计与实现","categories":[{"name":"神明难再的硬件之旅","slug":"神明难再的硬件之旅","permalink":"http://example.com/categories/%E7%A5%9E%E6%98%8E%E9%9A%BE%E5%86%8D%E7%9A%84%E7%A1%AC%E4%BB%B6%E4%B9%8B%E6%97%85/"}],"tags":[{"name":"RISC-V","slug":"RISC-V","permalink":"http://example.com/tags/RISC-V/"},{"name":"vivado","slug":"vivado","permalink":"http://example.com/tags/vivado/"},{"name":"chisel","slug":"chisel","permalink":"http://example.com/tags/chisel/"}]},{"title":"RISC-V CPU取指令阶段","slug":"RISC-V CPU取指令阶段","date":"2023-02-16T11:50:04.142Z","updated":"2023-02-17T14:54:45.186Z","comments":true,"path":"2023/02/16/RISC-V CPU取指令阶段/","link":"","permalink":"http://example.com/2023/02/16/RISC-V%20CPU%E5%8F%96%E6%8C%87%E4%BB%A4%E9%98%B6%E6%AE%B5/","excerpt":"","text":"取指令阶段在取出存储器中的指令的同时，还需要将 PC 寄存器自增，准备取下一条指令；同时还考虑了流水线，因此在取指令和译码阶段之间还需要一个模块来暂存之前取得的指令。 PC 模块1. 设计与实现上电之后，PC 寄存器需要从某个初始值开始读取指令，因此这个模块需要一个起始地址参数 init_addr，除此之外，还定义了总线宽度参数 n，这样即可通过修改参数生成 32/64 位的 CPU。chisel 会帮助生成 clock 和 reset，因此不需要额外定义这两个端口。代码如下： 12345678910111213141516171819202122232425262728293031package mycpu import chisel3._ class Pc(n: Int, init_addr: Int) extends Module&#123; val io = IO(new Bundle &#123; val pc = Output(UInt(n.W)) // 输出地址 val ce = Output(UInt(1.W)) // 用于在 reset 时禁止使用 pc 寄存器 &#125;) // 使用 chisel 寄存器部件，Reg 默认会在时钟上升沿进行操作 private val inner_pc = RegInit(init_addr.U(n.W)) io.pc := inner_pc private val inner_ce = RegInit(0.U(1.W)) io.ce := inner_ce // 只有当芯片使能时，pc 才会自增 when(inner_ce.asBool())&#123; inner_pc := inner_pc + (n / 8).U &#125;.otherwise&#123; inner_pc := init_addr.U(n.W) &#125; // 当复位时，芯片使能关闭 when(reset.asBool()) &#123; inner_ce := 0.U &#125;.otherwise &#123; inner_ce := 1.U &#125; &#125;// 生成 verilog 文件object PcTest extends App &#123; Driver.execute(Array(&quot;--target-dir&quot;, &quot;generated/Pc&quot;), () =&gt; new Pc(32, 0x1000)) &#125; 2. 仿真测试目前还没有板子，因此只进行了 RTL 级的仿真，先编写测试文件，每过 100 个时间单位，clk 取反来模拟时钟信号；每过 2000 个时间单位，reset 取反来模拟复位，再过 100 个时间单位，reset 取反来模拟芯片使能，pc 自增。代码如下： 1234567891011121314151617181920212223module PcTest;wire[31: 0] pc;wire ce;reg clk, reset;initial begin clk = 0; reset = 0;endalways #(100) begin clk = ~clk;endalways #(2000) begin reset = ~reset; #100 reset = ~reset;endPc p(.clock(clk), .reset(reset), .io_pc(pc), .io_ce(ce));endmodule vivado RTL 仿真波形如下： IF/ID 模块这个阶段主要是用于流水线 CPU 的设计，暂存了取指阶段取得的指令以及对应的指令地址，并在下一个时钟传递给译码阶段。这时，之前的模块可以继续取指。代码如下： 1","categories":[{"name":"神明难再的硬件之旅","slug":"神明难再的硬件之旅","permalink":"http://example.com/categories/%E7%A5%9E%E6%98%8E%E9%9A%BE%E5%86%8D%E7%9A%84%E7%A1%AC%E4%BB%B6%E4%B9%8B%E6%97%85/"}],"tags":[{"name":"RISC-V","slug":"RISC-V","permalink":"http://example.com/tags/RISC-V/"},{"name":"vivado","slug":"vivado","permalink":"http://example.com/tags/vivado/"},{"name":"chisel","slug":"chisel","permalink":"http://example.com/tags/chisel/"}]},{"title":"RISC-V CPU实现（序章）","slug":"RISC-V CPU实现（序章）","date":"2023-02-16T11:33:40.461Z","updated":"2023-02-16T15:23:24.343Z","comments":true,"path":"2023/02/16/RISC-V CPU实现（序章）/","link":"","permalink":"http://example.com/2023/02/16/RISC-V%20CPU%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%BA%8F%E7%AB%A0%EF%BC%89/","excerpt":"","text":"学完了一些工具和基本的语法之后，开始动手实现一个 RISC-V 的 CPU，先不考虑存储器这些 项目目标 支持参数化 功能目标 支持 RISC-V 整型指令","categories":[{"name":"神明难再的硬件之旅","slug":"神明难再的硬件之旅","permalink":"http://example.com/categories/%E7%A5%9E%E6%98%8E%E9%9A%BE%E5%86%8D%E7%9A%84%E7%A1%AC%E4%BB%B6%E4%B9%8B%E6%97%85/"}],"tags":[{"name":"RISC-V","slug":"RISC-V","permalink":"http://example.com/tags/RISC-V/"},{"name":"MPIS","slug":"MPIS","permalink":"http://example.com/tags/MPIS/"}]},{"title":"vivado 安装和使用（二）","slug":"vivado使用（二）","date":"2023-02-15T16:05:31.435Z","updated":"2023-02-16T15:22:27.164Z","comments":true,"path":"2023/02/16/vivado使用（二）/","link":"","permalink":"http://example.com/2023/02/16/vivado%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"没有板子，尚未开始","categories":[{"name":"神明难再的硬件之旅","slug":"神明难再的硬件之旅","permalink":"http://example.com/categories/%E7%A5%9E%E6%98%8E%E9%9A%BE%E5%86%8D%E7%9A%84%E7%A1%AC%E4%BB%B6%E4%B9%8B%E6%97%85/"}],"tags":[{"name":"vivado","slug":"vivado","permalink":"http://example.com/tags/vivado/"},{"name":"verilog","slug":"verilog","permalink":"http://example.com/tags/verilog/"}]},{"title":"vivado 安装和使用（一）","slug":"vivado使用（一）","date":"2023-02-15T15:16:38.480Z","updated":"2023-02-16T15:22:23.276Z","comments":true,"path":"2023/02/15/vivado使用（一）/","link":"","permalink":"http://example.com/2023/02/15/vivado%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"vivado 安装 从官网下载vivado 之后的安装在网上找个教程，按照提示一步一步安装 vivado 创建新项目 双击 vivado，进入到开始界面，点击创建新项目，选择项目名和安装位置 创建 RTL 项目，并勾选 Do not specify sources at this time 选择对应的部件，即可创建新项目 vivado 添加源文件以及测试文件 在 Sources 框中选中 Design Sources 目录之后点击上方的 ➕ 添加源文件，添加测试文件同理，选中 Simulation Sources 目录之后点击 ➕ 运行 RTL 仿真，选中 Simulation Sources 目录下的子目录 sim_1，右键点击对应按钮 若源文件和测试文件均没有出现错误，则会出现以下界面，可以在右侧观察波形图","categories":[{"name":"神明难再的硬件之旅","slug":"神明难再的硬件之旅","permalink":"http://example.com/categories/%E7%A5%9E%E6%98%8E%E9%9A%BE%E5%86%8D%E7%9A%84%E7%A1%AC%E4%BB%B6%E4%B9%8B%E6%97%85/"}],"tags":[{"name":"vivado","slug":"vivado","permalink":"http://example.com/tags/vivado/"},{"name":"verilog","slug":"verilog","permalink":"http://example.com/tags/verilog/"}]},{"title":"在 WSL 中安装 Java、Scala、sbt","slug":"WSL 安装 java、Scala、sbt","date":"2023-02-14T07:34:24.226Z","updated":"2023-02-15T15:18:26.812Z","comments":true,"path":"2023/02/14/WSL 安装 java、Scala、sbt/","link":"","permalink":"http://example.com/2023/02/14/WSL%20%E5%AE%89%E8%A3%85%20java%E3%80%81Scala%E3%80%81sbt/","excerpt":"","text":"环境支持因为上学期使用 wsl 进行了项目，所以不需要再安装 riscv 交叉编译工具链，只需要安装 chisel 的环境即可 安装 Java 从官网下载 jdk，复制到 wsl 中的相应目录下（/java） 在对应目录解压下载的压缩包1sudo tar zxvf jdk-17_linux-x64_bin.tar.gz 在 ~/.bashrc 中添加环境变量，并执行 source ~/.bashrc1234export JAVA_HOME=/java/jdk-17.0.6export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH 输入 java -version 验证是否安装成功 注意，vscode 的插件可能需要手动添加 JAVA_HOME，在 settings.json 中输入以下内容1234567&quot;java.autobuild.enabled&quot;: false,&quot;metals.javaHome&quot;: &quot;/java/jdk-17.0.6&quot;, // jdk 压缩包解压的位置&quot;java.configuration.runtimes&quot;: [&#123; &quot;name&quot;: &quot;JavaSE-17&quot;, &quot;path&quot;: &quot;/java/jdk-17.0.6&quot;, &quot;default&quot;: true&#125;], 安装 Scala1sudo apt install scala 安装 sbt 环境 从官网下载 sbt，复制到 wsl 中的相应目录下（~/sbt/） 在对应目录解压下载的压缩包 tar zxvf sbt-1.8.2.tgz，解压后的目录为12345678910111213141516sbt── sbt ├── LICENSE ├── NOTICE ├── bin │ ├── sbt │ ├── sbt-launch.jar │ ├── sbt.bat │ ├── sbtn-aarch64-pc-linux │ ├── sbtn-x86_64-apple-darwin │ ├── sbtn-x86_64-pc-linux │ └── sbtn-x86_64-pc-win32.exe ├── conf │ ├── sbtconfig.txt │ └── sbtopts └── sbt_text 在 sbt 目录下新建 sbt 脚本 sbt_text，输入以下内容12BT_OPTS=&quot;-Xms2048M -Xmx4096M -Xss1M -XX:+CMSClassUnloadingEnabled -XX:MaxPermSize=256M&quot;java $SBT_OPTS -jar ~/sbt/sbt/bin/sbt-launch.jar &quot;$@&quot; 修改脚本 sbt_text 属性 sudo chmod u+x sbt_text 在 ~/.bashrc 中添加环境变量，并执行 source ~/.bashrc12export SBT_HOME=~/sbt/sbtexport PATH=$&#123;SBT_HOME&#125;/bin:$PATH 输入 sbt version 验证是否安装成功，第一次初始化需要下载依赖包，若下载速度慢或者出现问题，则在 ~/.sbt/ 目录下新建 repositories 文件，添加以下内容12345[repositories]localhuaweicloud-maven: https://repo.huaweicloud.com/repository/maven/maven-central: https://repo1.maven.org/maven2/sbt-plugin-repo: https://repo.scala-sbt.org/scalasbt/sbt-plugin-releases, [organization]/[module]/(scala_[scalaVersion]/)(sbt_[sbtVersion]/)[revision]/[type]s/[artifact](-[classifier]).[ext] vscode 安装 wsl 中的 scala 插件，在插件商店搜索 Scala Extension Pack，里面有 13 个扩展包，按照需求安装即可（带有 scala 的即可），不需要安装所有的插件 在 Scala (Metals) 插件的设置中设置 Custom Repositories 和 Coursier Mirror，即在 settings.json 中输入以下内容1234&quot;metals.customRepositories&quot;: [ &quot;https://maven.aliyun.com/repository/central&quot;],&quot;metals.coursierMirror&quot;: &quot;https://maven.aliyun.com/repository/public&quot;, 不出意外，还是不能使用 Metals 插件新建 scala 项目，只会创建出一个空的目录，需要手动创建 build.sbt 文件，之后插件会提示是否需要引入 build 如果还存在其他什么问题，请自行 google","categories":[{"name":"神明难再的硬件之旅","slug":"神明难再的硬件之旅","permalink":"http://example.com/categories/%E7%A5%9E%E6%98%8E%E9%9A%BE%E5%86%8D%E7%9A%84%E7%A1%AC%E4%BB%B6%E4%B9%8B%E6%97%85/"}],"tags":[{"name":"wsl","slug":"wsl","permalink":"http://example.com/tags/wsl/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"scala","slug":"scala","permalink":"http://example.com/tags/scala/"},{"name":"sbt","slug":"sbt","permalink":"http://example.com/tags/sbt/"}]}],"categories":[{"name":"神明难再的硬件之旅","slug":"神明难再的硬件之旅","permalink":"http://example.com/categories/%E7%A5%9E%E6%98%8E%E9%9A%BE%E5%86%8D%E7%9A%84%E7%A1%AC%E4%BB%B6%E4%B9%8B%E6%97%85/"}],"tags":[{"name":"wsl","slug":"wsl","permalink":"http://example.com/tags/wsl/"},{"name":"riscv","slug":"riscv","permalink":"http://example.com/tags/riscv/"},{"name":"rocket-chip","slug":"rocket-chip","permalink":"http://example.com/tags/rocket-chip/"},{"name":"riscv-toolchain","slug":"riscv-toolchain","permalink":"http://example.com/tags/riscv-toolchain/"},{"name":"RISC-V","slug":"RISC-V","permalink":"http://example.com/tags/RISC-V/"},{"name":"vivado","slug":"vivado","permalink":"http://example.com/tags/vivado/"},{"name":"chisel","slug":"chisel","permalink":"http://example.com/tags/chisel/"},{"name":"MPIS","slug":"MPIS","permalink":"http://example.com/tags/MPIS/"},{"name":"verilog","slug":"verilog","permalink":"http://example.com/tags/verilog/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"scala","slug":"scala","permalink":"http://example.com/tags/scala/"},{"name":"sbt","slug":"sbt","permalink":"http://example.com/tags/sbt/"}]}